<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mathmons — Matematik Macerası</title>
<style>
  :root{
    --bg:#e9f2ff; --panel:#0b1630; --accent:#ffb86b; --text:#062033;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#cfe6ff, #e9f7ff);color:var(--text)}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px 18px}
  h1{margin:0;font-size:18px}
  main{display:flex;gap:12px;max-width:1100px;margin:8px auto;padding:12px}
  /* Canvas area */
  .game-area{background:#b7e0ff;padding:8px;border-radius:10px;box-shadow:0 6px 20px rgba(2,10,20,0.08)}
  canvas{display:block;border:4px solid #ffffff;border-radius:8px;background:#9fd8ff}
  /* Side panel */
  .panel{width:320px;padding:12px;border-radius:10px;background:linear-gradient(180deg,#fff,#f2fbff);box-shadow:0 6px 20px rgba(2,10,20,0.06)}
  .stat{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px dashed rgba(2,10,20,0.04)}
  .btn{display:inline-block;padding:8px 10px;border-radius:8px;background:var(--panel);color:#fff;border:none;cursor:pointer;margin:6px 4px}
  .small{font-size:13px;color:#23456a}
  /* modal */
  #modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,8,20,0.45);z-index:30}
  .card{background:#fff;padding:16px;border-radius:10px;min-width:280px;box-shadow:0 10px 30px rgba(2,10,20,0.3)}
  .question{font-size:18px;margin-bottom:8px}
  input[type="text"]{width:100%;padding:8px;border-radius:8px;border:1px solid #cddff0;font-size:16px}
  .row{display:flex;gap:8px;align-items:center;margin-top:10px}
  .list{max-height:220px;overflow:auto;padding:6px;border-radius:8px;border:1px solid #e0f0ff;background:#fbffff}
  footer{text-align:center;color:#6c8aa6;padding:12px}
  /* mobile controls */
  .touch-controls{display:none;margin-top:8px;gap:6px}
  .touch-controls button{padding:10px;border-radius:8px}
  @media(max-width:920px){
    main{flex-direction:column;align-items:center;padding:8px}
    .panel{width:94%}
    .touch-controls{display:flex}
  }
</style>
</head>
<body>
<header>
  <h1>Mathmons — Küçük Dünyada Matematik Macerası</h1>
  <div style="text-align:right">
    <div style="font-size:12px;color:#2b4b63">⚡ Klavye: ok tuşları | Dokunmatik: ekranda kontrol</div>
  </div>
</header>

<main>
  <div class="game-area">
    <canvas id="world" width="640" height="480"></canvas>
    <div style="display:flex;justify-content:space-between;margin-top:8px">
      <div class="small">Pozisyon: <span id="pos">0,0</span></div>
      <div class="small">Puan: <strong id="score">0</strong></div>
      <div class="small">Yakalanan: <strong id="caught">0</strong></div>
    </div>

    <div class="touch-controls" style="justify-content:center">
      <button id="up">↑</button>
    </div>
    <div class="touch-controls" style="justify-content:space-between">
      <button id="left">←</button>
      <button id="down">↓</button>
      <button id="right">→</button>
    </div>
  </div>

  <aside class="panel">
    <div class="stat"><div>Seviye</div><div id="level">1</div></div>
    <div class="stat"><div>Kalan İşlem Kutusu</div><div id="boxes">—</div></div>
    <div style="margin-top:8px">
      <div style="font-weight:600">Envanter / Yakalanan Mathmons</div>
      <div class="list" id="inventory"></div>
    </div>

    <div style="margin-top:10px">
      <button class="btn" id="newGame">Yeni Oyun</button>
      <button class="btn" id="spawn">Rastgele Kutular Ekle</button>
    </div>

    <div style="margin-top:12px">
      <div style="font-weight:600;margin-bottom:6px">Nasıl oynanır?</div>
      <div class="small">• Haritada yürüyüp işlem kutularını ve Mathmon'ları bul. <br>• Kutulara çarpınca soruyu çöz — doğruysa puan kazanırsın. <br>• Mathmon ile karşılaşınca onu yakalamak için soru çöz. Doğruysa Mathmon envantere eklenir.</div>
    </div>
  </aside>
</main>

<div id="modal">
  <div class="card">
    <div class="question" id="qtext">Soru buraya</div>
    <input id="qinput" type="text" placeholder="Cevabını yaz..." />
    <div class="row">
      <button class="btn" id="qsubmit">Gönder</button>
      <button class="btn" id="qskip">Vazgeç</button>
      <div style="flex:1;text-align:right;color:#567fa3">Kalan süre: <span id="qtime">12</span>s</div>
    </div>
  </div>
</div>

<footer>Bu oyun tek dosya olarak tasarlandı — GitHub Pages'e koyup oynayabilirsin.</footer>

<script>
/* ---------- Oyun Konfig ---------- */
const TILE_W = 64, TILE_H = 64;
const MAP_COLS = 10, MAP_ROWS = 7;         // 10x7 grid (dürüstçe küçük dünya)
const CANVAS_W = TILE_W * MAP_COLS;       // 640
const CANVAS_H = TILE_H * MAP_ROWS;       // 448
const INITIAL_BOXES = 8;
const INITIAL_MATHMONS = 3;
const QUESTION_TIME = 12; // saniye

/* ---------- Oyun Durumu ---------- */
const canvas = document.getElementById('world');
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');

let state = {
  player: {x: Math.floor(MAP_COLS/2), y: Math.floor(MAP_ROWS/2)},
  boxes: [],    // işlem kutuları {x,y,type}
  mathmons: [], // mathmonlar {x,y,name,level}
  score: 0,
  level: 1,
  inventory: [],
  runningQuestion: null,
  questionTimerId: null
};

/* ---------- UI refs ---------- */
const posEl = document.getElementById('pos');
const scoreEl = document.getElementById('score');
const boxesEl = document.getElementById('boxes');
const invEl = document.getElementById('inventory');
const lvlEl = document.getElementById('level');
const caughtEl = document.getElementById('caught');

const modal = document.getElementById('modal');
const qtext = document.getElementById('qtext');
const qinput = document.getElementById('qinput');
const qtime = document.getElementById('qtime');
const qsubmit = document.getElementById('qsubmit');
const qskip = document.getElementById('qskip');

/* ---------- Yardımcı Fonksiyonlar ---------- */
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function tileToPx(tx,ty){ return {px: tx * TILE_W, py: ty * TILE_H}; }
function samePos(a,b){ return a.x===b.x && a.y===b.y; }

/* ---------- Harita / Spawn ---------- */
function spawnBoxes(n=INITIAL_BOXES){
  // türler: + - * /
  const types = ['+','-','×','÷'];
  let attempts = 0;
  while(n>0 && attempts<500){
    attempts++;
    const x = randInt(0,MAP_COLS-1), y = randInt(0,MAP_ROWS-1);
    // boş hücre ve oyuncudan farklı
    if(x===state.player.x && y===state.player.y) continue;
    if(state.boxes.find(b=>b.x===x && b.y===y)) continue;
    if(state.mathmons.find(m=>m.x===x && m.y===y)) continue;
    const type = types[randInt(0,types.length-1)];
    state.boxes.push({x,y,type});
    n--;
  }
  updateUI();
}

function spawnMathmons(n=INITIAL_MATHMONS){
  const names = ['Addrex','Subbi','Multo','Divi','Numble','Fracto'];
  let attempts = 0;
  while(n>0 && attempts<500){
    attempts++;
    const x = randInt(0,MAP_COLS-1), y = randInt(0,MAP_ROWS-1);
    if(x===state.player.x && y===state.player.y) continue;
    if(state.boxes.find(b=>b.x===x && b.y===y)) continue;
    if(state.mathmons.find(m=>m.x===x && m.y===y)) continue;
    const name = names[randInt(0,names.length-1)];
    const level = Math.max(1, state.level + randInt(-1,1));
    state.mathmons.push({x,y,name,level});
    n--;
  }
  updateUI();
}

/* ---------- Soru Üretici ---------- */
function generateQuestionForType(type, difficulty=1){
  // difficulty ile sayı büyür
  const max = 5 + difficulty*6;
  let a = randInt(1, max);
  let b = randInt(1, max);
  let question = '', answer = null;
  if(type === '+'){ question = `${a} + ${b} = ?`; answer = a + b; }
  else if(type === '-'){
    if(a < b) [a,b]=[b,a];
    question = `${a} - ${b} = ?`; answer = a - b;
  } else if(type === '×'){
    question = `${a} × ${b} = ?`; answer = a * b;
  } else if(type === '÷'){
    // bölme için tam bölünebilir yap
    answer = randInt(1, Math.max(1, Math.floor(max/2)));
    b = randInt(1, Math.max(1, Math.floor(max/2)));
    a = answer * b;
    question = `${a} ÷ ${b} = ?`;
  } else {
    // Mathmon karşılaşma rastgele işlem
    const ops = ['+','-','×','÷'];
    const t = ops[randInt(0,ops.length-1)];
    return generateQuestionForType(t,difficulty);
  }
  return {question,answer};
}

function generateQuestionForMathmon(mathmon){
  // mathmon level etkiler
  const diff = Math.max(1, mathmon.level);
  // rastgele operation (bonus olarak mix)
  const ops = ['+','-','×','÷'];
  const type = ops[randInt(0,ops.length-1)];
  const q = generateQuestionForType(type, diff);
  // attach metadata
  q.meta = {type,mathmon};
  return q;
}

/* ---------- Soru Modal İşlemleri ---------- */
function openQuestionModal(q, onCorrect, onFail){
  state.runningQuestion = {q,onCorrect,onFail,remaining: QUESTION_TIME};
  qtext.innerText = q.question;
  qinput.value = '';
  qtime.innerText = state.runningQuestion.remaining;
  modal.style.display = 'flex';
  qinput.focus();

  // timer
  if(state.questionTimerId) clearInterval(state.questionTimerId);
  state.questionTimerId = setInterval(()=>{
    state.runningQuestion.remaining -= 1;
    qtime.innerText = state.runningQuestion.remaining;
    if(state.runningQuestion.remaining <= 0){
      clearInterval(state.questionTimerId);
      closeQuestionModal();
      if(onFail) onFail();
    }
  },1000);
}

function closeQuestionModal(){
  modal.style.display = 'none';
  if(state.questionTimerId){ clearInterval(state.questionTimerId); state.questionTimerId = null; }
  state.runningQuestion = null;
}

/* ---------- Etkileşim: Kutular ve Mathmonlar ---------- */
function handleStep(){
  // oyuncu bir kutu ile aynı hücreye geldi mi?
  const p = state.player;
  const box = state.boxes.find(b=>b.x===p.x && b.y===p.y);
  if(box){
    // soru üret
    const q = generateQuestionForType(box.type, state.level);
    openQuestionModal(q, ()=>{
      // doğruysa puan ve kutuyu al
      state.score += 10 * state.level;
      // kutuyu sil
      const idx = state.boxes.indexOf(box);
      if(idx>=0) state.boxes.splice(idx,1);
      updateUI();
    }, ()=>{
      // yanlış: puan kaybı
      state.score = Math.max(0, state.score - 5);
      updateUI();
    });
    return;
  }
  // mathmon var mı?
  const mm = state.mathmons.find(m=>m.x===p.x && m.y===p.y);
  if(mm){
    const q = generateQuestionForMathmon(mm);
    openQuestionModal(q, ()=>{
      // doğru -> yakala
      state.inventory.push({name:mm.name,level:mm.level});
      state.score += 30 * mm.level;
      // mathmonu sil
      const idx = state.mathmons.indexOf(mm);
      if(idx>=0) state.mathmons.splice(idx,1);
      updateUI();
    }, ()=>{
      // yanlış -> mathmon kaçıyor (rastgele başka yere taşınsın)
      mm.x = randInt(0,MAP_COLS-1);
      mm.y = randInt(0,MAP_ROWS-1);
      updateUI();
    });
    return;
  }
}

/* ---------- Kontrol ve Input ---------- */
const keys = {};
window.addEventListener('keydown', e=>{
  if(e.key.startsWith('Arrow')){ e.preventDefault(); }
  keys[e.key] = true;
  // modal açıkken Enter ile gönder
  if(modal.style.display === 'flex' && e.key === 'Enter'){ qsubmit.click(); }
});
window.addEventListener('keyup', e=>{ keys[e.key] = false; });

document.getElementById('up').addEventListener('click', ()=>movePlayer(0,-1));
document.getElementById('left').addEventListener('click', ()=>movePlayer(-1,0));
document.getElementById('down').addEventListener('click', ()=>movePlayer(0,1));
document.getElementById('right').addEventListener('click', ()=>movePlayer(1,0));

function movePlayer(dx,dy){
  if(state.runningQuestion) return; // soru açıkken hareket yok
  const nx = clamp(state.player.x + dx, 0, MAP_COLS-1);
  const ny = clamp(state.player.y + dy, 0, MAP_ROWS-1);
  state.player.x = nx; state.player.y = ny;
  updateUI();
  handleStep();
  draw();
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* allow arrow keys as movement with small cooldown */
let lastMove = 0;
function processKeyboard(){
  const now = Date.now();
  if(now - lastMove < 140) return;
  if(keys['ArrowUp'] || keys['w']){ movePlayer(0,-1); lastMove = now; }
  else if(keys['ArrowDown'] || keys['s']){ movePlayer(0,1); lastMove = now; }
  else if(keys['ArrowLeft'] || keys['a']){ movePlayer(-1,0); lastMove = now; }
  else if(keys['ArrowRight'] || keys['d']){ movePlayer(1,0); lastMove = now; }
}

/* ---------- UI Güncelle ---------- */
function updateUI(){
  posEl.innerText = `${state.player.x}, ${state.player.y}`;
  scoreEl.innerText = state.score;
  boxesEl.innerText = state.boxes.length;
  lvlEl.innerText = state.level;
  invEl.innerHTML = state.inventory.length ? state.inventory.map(m=>`${m.name} (Lv${m.level})`).join('<br>') : '<i>Boş</i>';
  caughtEl.innerText = state.inventory.length;
}

/* ---------- Çizim ---------- */
function drawGrid(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // zemin
  ctx.fillStyle = '#cfeeff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // grid çizgileri
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  for(let c=0;c<=MAP_COLS;c++){
    ctx.beginPath(); ctx.moveTo(c*TILE_W,0); ctx.lineTo(c*TILE_W,canvas.height); ctx.stroke();
  }
  for(let r=0;r<=MAP_ROWS;r++){
    ctx.beginPath(); ctx.moveTo(0,r*TILE_H); ctx.lineTo(canvas.width,r*TILE_H); ctx.stroke();
  }
}

function draw(){
  drawGrid();
  // kutuları çiz
  for(const b of state.boxes){
    const {px,py} = tileToPx(b.x,b.y);
    ctx.fillStyle = '#fff9c4';
    ctx.fillRect(px+8,py+8,TILE_W-16,TILE_H-16);
    ctx.fillStyle = '#223344';
    ctx.font = '28px sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillText(b.type, px + TILE_W/2, py + TILE_H/2);
  }
  // mathmons (yuvarlak sevimli)
  for(const m of state.mathmons){
    const {px,py} = tileToPx(m.x,m.y);
    // body
    ctx.fillStyle = '#ffd1dc';
    ctx.beginPath(); ctx.ellipse(px+TILE_W/2, py+TILE_H/2, 20, 20,0,0,Math.PI*2); ctx.fill();
    // eyes
    ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(px+TILE_W/2-6,py+TILE_H/2-4,3,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(px+TILE_W/2+6,py+TILE_H/2-4,3,0,Math.PI*2); ctx.fill();
    // name
    ctx.fillStyle = '#123'; ctx.font='12px sans-serif'; ctx.textAlign='center';
    ctx.fillText(`${m.name} (Lv${m.level})`, px+TILE_W/2, py+TILE_H-6);
  }
  // player (küçük kare)
  const pp = tileToPx(state.player.x, state.player.y);
  ctx.fillStyle = '#4a90e2';
  ctx.fillRect(pp.px+12, pp.py+12, TILE_W-24, TILE_H-24);
  ctx.fillStyle = '#fff'; ctx.font='14px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('YOU', pp.px+TILE_W/2, pp.py+TILE_H/2);
}

/* ---------- Oyun Döngüsü ---------- */
function gameLoop(){
  processKeyboard();
  draw();
  requestAnimationFrame(gameLoop);
}

/* ---------- Butonlar ve Etkinlikler ---------- */
document.getElementById('newGame').addEventListener('click', ()=>{
  state.player = {x: Math.floor(MAP_COLS/2), y: Math.floor(MAP_ROWS/2)};
  state.boxes = [];
  state.mathmons = [];
  state.inventory = [];
  state.score = 0;
  state.level = 1;
  spawnBoxes(INITIAL_BOXES);
  spawnMathmons(INITIAL_MATHMONS);
  updateUI();
  draw();
});
document.getElementById('spawn').addEventListener('click', ()=>{ spawnBoxes(4); spawnMathmons(1); });

qsubmit.addEventListener('click', ()=>{
  if(!state.runningQuestion) return;
  const given = qinput.value.trim();
  if(given==='') return;
  const correct = String(state.runningQuestion.q.answer);
  if(given === correct){
    // doğru
    const cb = state.runningQuestion.onCorrect;
    closeQuestionModal();
    if(cb) cb();
  } else {
    // yanlış
    const cb = state.runningQuestion.onFail;
    closeQuestionModal();
    if(cb) cb();
  }
});

qskip.addEventListener('click', ()=>{
  if(!state.runningQuestion) return;
  const cb = state.runningQuestion.onFail;
  closeQuestionModal();
  if(cb) cb();
});

/* ---------- Başlangıç ---------- */
spawnBoxes(INITIAL_BOXES);
spawnMathmons(INITIAL_MATHMONS);
updateUI();
draw();
requestAnimationFrame(gameLoop);

/* ---------- Küçük yardımcı: fare ile hücre tıklama hareketi ---------- */
canvas.addEventListener('click', e=>{
  // tıklanan hücreye gitmek yerine direkt move (öğretici amaçlı)
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const tx = Math.floor(mx / TILE_W), ty = Math.floor(my / TILE_H);
  // doğruysa hareket et
  // hesapla dx,dy tek adım olacak şekilde
  const dx = Math.sign(tx - state.player.x);
  const dy = Math.sign(ty - state.player.y);
  if(dx !== 0) movePlayer(dx,0); else if(dy !== 0) movePlayer(0,dy);
});

/* ---------- İpuçları / geliştirilebilir notlar ---------- */
/*
  - İstersen mathmonlara özel sorular, daha erken seviye/evrim mekanikleri ekleyebilirim.
  - Görsel iyileştirmesi, ses efektleri, seviye geçişleri istersen eklerim.
  - Bu dosyayı GitHub Pages'e koyup paylaşmak istersen yardım edeyim.
*/
</script>
</body>
</html>
